name: Production-Grade Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  infra-and-deploy:
    name: Provision & Deploy to Production
    runs-on: ubuntu-latest
    environment:
      name: prod
      url: https://nexus-sus-alb-prod-XXXXX.us-east-1.elb.amazonaws.com
    
    steps:
      - name: Remove Old DynamoDB Reference
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          # Deletar a tabela antiga (se existir)
          aws dynamodb delete-table --table-name terraform-locks 2>/dev/null || true
          
          # Aguardar deletion
          sleep 20
          
          echo "‚úÖ Tabela antiga removida"

      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Nuclear Clean Cache
        run: |
          # Remover TUDO de terraform na m√°quina da pipeline
          rm -rf infra/.terraform
          rm -rf infra/.terraform.lock.hcl
          rm -rf infra/terraform.tfstate*
          rm -rf ~/.terraform*
          rm -rf /tmp/terraform*
          
          # Limpar env vars
          unset TF_LOG
          unset TF_LOG_PATH
          unset TF_DATA_DIR
          
          echo "‚úÖ Cache limpo"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Backup State
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws s3 cp s3://nexus-sus-terraform-state/prod/terraform.tfstate \
            s3://nexus-sus-terraform-state/prod/terraform.tfstate.backup.$(date +%s) || true
          echo "‚úÖ State backed up"

      - name: Terraform Plan & Apply
        working-directory: infra
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_environment: prod
          TF_VAR_db_username: nexus_admin
          TF_VAR_admin_password: ${{ secrets.DB_PASSWORD }}
        run: |
          terraform init \
            -backend-config="bucket=nexus-sus-terraform-state" \
            -backend-config="key=prod/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="dynamodb_table=nexus-sus-terraform-locks"
          
          terraform plan -var-file="prod.tfvars" -out=tfplan
          terraform apply -auto-approve tfplan
          
          echo "‚úÖ Production deployed"


      - name: Validate Deployment
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          echo "üïµÔ∏è Validando Infra..."
          VPC_COUNT=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=nexus-sus-vpc-prod" --query 'length(Vpcs)' --output text)
          echo "VPCs encontradas: $VPC_COUNT"
          
          NAT_COUNT=$(aws ec2 describe-nat-gateways --filter "Name=tag:Name,Values=*prod*" --query "length(NatGateways[?State!='deleted'])" --output text)
          echo "NAT gateways ativos: $NAT_COUNT"
          
          ALB_DNS=$(aws elbv2 describe-load-balancers --query "LoadBalancers[?contains(LoadBalancerName, 'nexus-sus-alb-prod')].DNSName" --output text || echo "none")
          echo "ALB Endpoint: $ALB_DNS"
          
          if [ "$VPC_COUNT" -gt 0 ]; then
            echo "‚úÖ Valida√ß√£o b√°sica passou"
          else
            echo "‚ùå Falha na valida√ß√£o: Nenhuma VPC prod encontrada"
            exit 1
          fi
          
          # Health check b√°sico
          if [ "$ALB_DNS" != "none" ]; then
             curl -f --connect-timeout 5 http://$ALB_DNS/api/health || echo "   ‚ö†Ô∏è ALB ainda estabilizando..."
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, Tag and Push Images (-O3 Optimized)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Build API/Engine with C++ -O3 (handled inside API Dockerfile/Build context)
          docker build -t $ECR_REGISTRY/nexus-sus-api-prod:latest -f api/Dockerfile .
          docker push $ECR_REGISTRY/nexus-sus-api-prod:latest
          
          # Build Frontend
          docker build -t $ECR_REGISTRY/nexus-sus-frontend-prod:latest ./nexus-sus-frontend
          docker push $ECR_REGISTRY/nexus-sus-frontend-prod:latest

      - name: Update ECS Services
        run: |
          aws ecs update-service --cluster nexus-sus-cluster-prod --service nexus-sus-api-service-prod --force-new-deployment
          aws ecs update-service --cluster nexus-sus-cluster-prod --service nexus-sus-frontend-service-prod --force-new-deployment
